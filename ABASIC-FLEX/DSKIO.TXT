 NAM DSK2.1F
 OPT NOG,PAG
 SPC2
* DISK I/O ROUTINES FOR A/BASIC V2.1F
*
* MINIFLEX DISK VERSION
*
* (RUN TIME ROUTINES)
*
* 4/25/78 KEN KAPLAN
* 9/22/78 LARRY CRANE
 SPC2
*  TEMP STORAGE DEFINITION
BUFPTR EQU $22 INPUT BUFFER POINTER
ZONE EQU $26 BUFFER COUNT
FCBTMP EQU $10 FILE CONTROL BLOCK TEMP
ERRADR EQU $12 ERROR RETURN ADDR
ERRTYP EQU $14 ERROR TYPE RETURN
 SPC2
* REFERENCES TO FLEX ROUTINES
FLEX EQU $B406 SERVICE REQUEST ENTRY
REENTR EQU $AD06 RE-ENTRY
ZFLSPC EQU $AD2D BUILD FCB ROUTINE
SETEXT EQU $AD33 SET FILE EXTENSION
FLXLPT EQU $AC14 LINE INPUT POINTER ADDR
TMPFCB EQU $A840 ADDR OF TEMP FCB
 SPC1
OPNR EQU 1
OPNW EQU 2
CLSF EQU 4
RWDF EQU 5
DLTF EQU $C
 SPC2
 ORG $1F20
BEG EQU *
 SPC4
* ROUTINES ARE ENTERED WITH THE XR POINTING
* TO THE FILE'S FCB ADDR EXCEPT FOR <KILL> AND
* <OPEN> IN WHICH CASE THE XR IS THE POINTER TO
* THE FILE NAME STRING ADDR AND THE FCB ADDR
* IS STORED IN <FCBTMP>.
 SPC3
* OPEN FILE SUBR.
*
* ENTER WITH: FCB ADDR IN <FCBTMP>
*             XR > FILE NAME STRING
*
* OPENS FILE FOR READ IF IT EXISTS, OTHERWISE
* OPENED FOR WRITE
 SPC1
ZOPEN BSR FILNAM GET FILENAME IN FCB
 LDAB #OPNW OPEN-WRITE CODE
 LDX FCBTMP GET FCB ADDR IN XR
 CLR 2,X CLEAR ACTIVITY STATUS
 BSR DSKOP TRY TO OPEN
 BEQ RETURN IF OK WE'RE DONE
 BRA OPENRD TRY TO OPEN FOR READ
 SPC2
* CLOSE FILE SUBR.
* CLOSES A READ OR WRITE FILE
* ENTER WITH: FCB ADDR IN XR
 SPC1
ZCLOSE STX FCBTMP SAVE FCB ADDR
 LDAB 2,X GET FILE STATUS
 BEQ RETURN WAS NEVER OPEN
 LDAB #CLSF CLOSE CODE
 BRA FILOPR CLOSE IT
 SPC2
* RESTORE FILE (REWIND)
* CLOSES FILE AND RE-OPENS FOR READ
* ENTER W/XR > FCB ADDR
 SPC1
ZREST BSR ZCLOSE CLOSE IT
OPENRD LDAB #OPNR OPEN READ CODE
 BRA FILOPR .. AND OPEN IT
 SPC3
* FLEX INTERFACE/ERROR DETECTION/RECOVERY
* SUBROUTINES
 SPC2
* CALL FLEX SUBR
DSKOP STAB 0,X PUT FUNCTION CODE IN FCB
 JMP FLEX GO TO DFM ENTRY POINT
 SPC2
* ERROR RECOVERY - SAVE ERROR TYPE, TEST FOR
* RECOVERY ENTRY POINT, AND JUMP IF SET
FILERR LDAB 1,X GET ERROR TYPE
 STAB ERRTYP SAVE IT
 LDX ERRADR GET ERROR ADDR
 BEQ RETURN RETURN IF NOT SET
 JMP 0,X GO TO IT
 SPC2
* GENERAL DISK OP CALL WITH ERROR DETECT
FILOPR LDX FCBTMP GET FCB ADDR
 BSR DSKOP DO IT
 BEQ RETURN RETURN IF NO ERROR
 LDAB 1,X GET ERROR TYPE
 CMPB #8 END OF FILE?
 BNE FILERR ERROR IF NOT
 BSR ZLDX1 GET I/O BUFF POINTER
 STX BUFPTR MAKE EMPTY RECORD
 LDAA #$D END OF RECORD BYTE
RETURN RTS
 SPC3
* SCRATCH FILE
* DELETES FILE AND RE-OPENS FOR WRITE
* ENTER W/ XR > FCB ADDR
 SPC1
ZSCR LDAB 2,X GET STATUS
 CMPB #2 OPEN FOR WRITE?
 BNE ZSCR0 BRANCH IF NOT
 TST 22,X ANYTHING WRITTEN?
 BNE ZSCR0 BRANCH IF SO
 TST 21,X ANYTHING WRITTEN?
 BEQ RETURN BRANCH IF NOT
ZSCR0 BSR ZCLOSE CLOSE IT PROPERLY
 LDAB #11
 LDX FCBTMP SAVE FILE NAME ON STACK
ZSCR1 LDAA 4,X
 PSHA
 INX
 DECB
 BNE ZSCR1
 BSR DELETE DELETE FILE
 LDAB #11
 LDX FCBTMP RESTORE FILE NAME
ZSCR2 PULA
 STAA 14,X
 DEX
 DECB
 BNE ZSCR2
OPENWR LDAB #OPNW CODE FOR OPEN WRITE
 BRA FILOPR DO IT
 SPC3
* KILL FILE ROUTINE
* DELETE FILE FROM DISK
* ENTER WITH: FCB ADDR IN FCBTMP
*             XR > FILE NAME STRING
 SPC1
ZKILL BSR FILNAM GET NAME IN FCB
DELETE LDAB #DLTF CODE FOR DELETE FILE
 BRA FILOPR
 SPC2
* SUBR TO PUT FILE NAME STRING IN FCB
FILNAM STX FLXLPT GIVE IT TO DOS
 LDX FCBTMP GET FCB ADDR IN XR
 JSR ZFLSPC LET DFM ROUTINE PROCESS ...
 BCS FILERR GOTO ERROR ROUTINE IF BAD
 LDAA #1 SET DEFAULT '.TXT'
 JSR SETEXT
 RTS DONE
 SPC2
ZLDX1 BRA ZLDX
 SPC2
* RECORD READ ROUTINE - READ A RECORD FROM
* FILE SPECIFIED IN FCB TO INPUT BUFFER
* ENTER W/FCB ADDR IN XR
 SPC1
ZRECRD STX FCBTMP SAVE FCB POINTER
 BSR ZLDX GET I/O BUFF POINTER
ZREAD2 STX BUFPTR
 CLRB READ/WRITE CODE
 BSR FILOPR DO IT
 LDX BUFPTR GET POINTER
 STAA 0,X SAVE THE BYTE
 INX BUMP PTR
 CMPA #$D END OF RECORD?
 BNE ZREAD2 BRANCH IF NOT
ZREAD3 RTS
 SPC3
* WRITE RECORD ON FILE SPECIFIED BY FCB.
* ENTER W/FCB ADDR IN XR
* WRITES I/O BUFFER ON FILE
 SPC1
ZWRITE LDX BUFPTR GET CURRENT POSITION POINTER
 LDAA #$D END OF RECORD BYTE
 DEX BACK UP TO LAST SEPARATOR
 STAA 0,X SET END OF RECORD
 BSR ZLDX GET I/O BUFF POINTER
ZWRIT2 STX BUFPTR SAVE I/O PTR
 LDAA 0,X GET NEXT BYTE FROM BUFFER
 PSHA SAVE IT
 CLRB READ/WRITE CODE
 BSR FILOPR DO IT
 PULA RESTORE THE BYTE
 CMPA #$D END OF RECORD?
 BEQ ZREAD3 IF SO DONE - GOTO CLEAN UP
 LDX BUFPTR RESTOR PTR
 INX BUMP IT
 BRA ZWRIT2 GET MORE BYTES
 SPC2
* CHAIN (LOAD + GO) ROUTINE
* ENTER W/XR>STRING (FILE NAME)
*  FCB ADDR IN FCBTMP
 SPC1
XCHAIN STX FLXLPT
 JMP REENTR
 SPC2
* END OF FILE TEST
* ENTER W/XR>FCB
 SPC1
ZEOF LDAB 1,X
 CMPB #8
 BEQ ZEOF1
 CLRB
 BRA ZEOF2
ZEOF1 LDAB #1
ZEOF2 CLRA
 RTS
 SPC2
ZLDX EQU *
 SPC2
* OFFSETS
 SPC1
OPEN EQU ZOPEN-BEG
CLOSE EQU ZCLOSE-BEG
RESTO EQU ZREST-BEG
SCRAT EQU ZSCR-BEG
KILL EQU ZKILL-BEG
READ EQU ZRECRD-BEG
WRITE EQU ZWRITE-BEG
CHAIN EQU XCHAIN-BEG
EOF EQU ZEOF-BEG
 SPC2
LENGTH EQU *-BEG
 END
